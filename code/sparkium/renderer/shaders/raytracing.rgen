#version 460
#extension GL_EXT_ray_tracing : enable
#extension GL_EXT_nonuniform_qualifier : enable
#extension GL_EXT_ray_query : enable

#include "entity_metadata.glsl"
#include "material.glsl"
#include "mesh_metadata.glsl"
#include "ray_payload.glsl"
#include "scene_settings.glsl"

Material material;

layout(set = 0, binding = 0, std140) uniform SceneSettingsUniform {
  SceneSettings scene_settings;
};

layout(set = 0, binding = 1, std430) buffer MaterialBuffer {
  Material materials[];
};

layout(set = 0, binding = 2, std430) buffer EntityMetadataBuffer {
  EntityMetadata metadatas[];
};

layout(set = 1, binding = 0) uniform
    accelerationStructureEXT scene;  // Built in attribute, don't need to define

layout(set = 2, binding = 0, std430) buffer VertexBuffers {
  float vertex_data[];
}
vertex_buffers[];

layout(set = 2, binding = 1, std430) buffer IndexBuffers {
  uint indices[];
}
index_buffers[];

layout(set = 2, binding = 2) buffer AreaCDFBuffers {
  float area_cdfs[];
}
mesh_cdf_buffers[];

layout(set = 2, binding = 3, std430) buffer MeshMetadataBuffers {
  MeshMetadata mesh_metadatas[];
};

layout(set = 2, binding = 4) uniform texture2D sampled_textures[];

layout(set = 2, binding = 5) uniform sampler samplers[];

#define ENVMAP_SET 3
#include "envmap.glsl"

layout(set = ENVMAP_SET, binding = 2, std430) buffer EnvmapCdfData {
  float envmap_cdf[];
};

#include "random.glsl"

layout(set = 4, binding = 0, rgba8) uniform image2D result_image;

layout(set = 4,
       binding = 1,
       rgba32f) uniform image2D accumulated_radiance_image;

layout(set = 4, binding = 2, r32f) uniform image2D accumulated_weight_image;

layout(set = 4, binding = 3, rgba32f) uniform image2D raw_result_image;

layout(location = 0) rayPayloadEXT RayPayload ray_payload;

#include "hit_record.glsl"
#include "shadow_ray.glsl"
#include "trace_ray.glsl"

vec4 SampleTextureLinear(uint texture_id, vec2 uv) {
  return texture(sampler2D(sampled_textures[texture_id], samplers[0]), uv);
}

vec4 SampleTextureNearest(uint texture_id, vec2 uv) {
  return texture(sampler2D(sampled_textures[texture_id], samplers[1]), uv);
}

vec3 EnvmapSample(vec3 direction) {
  return texture(
             sampler2D(sampled_textures[envmap_data.envmap_id], samplers[0]),
             SampleEnvmapUV(direction))
             .xyz *
         envmap_data.scale;
}

Material GetMaterial(HitRecord hit_record) {
  Material material = materials[hit_record.entity_id];
  material.normal = normalize(mat3(hit_record.tangent, hit_record.bitangent,
                                   hit_record.shading_normal) *
                              ((material.normal - 0.5) * 2.0));
  material.base_color *=
      SampleTextureLinear(hit_record.albedo_texture_id, hit_record.tex_coord)
          .xyz *
      SampleTextureLinear(
          hit_record.albedo_detail_texture_id,
          hit_record.tex_coord * hit_record.detail_scale_offset.xy +
              hit_record.detail_scale_offset.zw)
          .xyz;
  return material;
}

// Sample a random point on the hemisphere with a cosine-weighted distribution
vec3 SampleHemisphere(vec3 normal) {
    // Randomly sample spherical coordinates
    float xi1 = RandomFloat();
    float xi2 = RandomFloat();

    // Convert from spherical to Cartesian coordinates
    // theta is the angle from the normal
    float theta = acos(sqrt(1.0 - xi1));  // theta ¡Ê [0, pi]
    float phi = 2.0 * PI * xi2;            // phi ¡Ê [0, 2*pi]

    // Spherical to Cartesian conversion
    float x = sin(theta) * cos(phi);
    float y = sin(theta) * sin(phi);
    float z = cos(theta);

    // Create the hemisphere direction based on the surface normal
    vec3 sampledDirection = vec3(x, y, z);

    // If the normal vector is pointing downward, reverse the direction
    if (dot(normal, sampledDirection) < 0.0) {
        sampledDirection = -sampledDirection;
    }

    return sampledDirection;
}

vec3 SampleBRDF(HitRecord hit_record, Material material, vec3 wo, out float pdf, out float cosine, out vec3 fr) {
    vec3 wi=vec3(0.0);
    if (material.type == MATERIAL_TYPE_LAMBERTIAN){
        // Sample a random hemisphere direction wi
        wi = SampleHemisphere(hit_record.shading_normal);

        // Compute the cosine of the angle between the normal and the incoming direction
        cosine = max(1e-3, dot(hit_record.shading_normal, wi));

        // The probability density function for Lambertian BRDF is constant (1 / 2¦Ð)
        pdf = 1.0 / PI / 2.0;
        
        // BRDF for specular material    
        fr = material.base_color / PI;
    }
    if (material.type == MATERIAL_TYPE_SPECULAR){
        // Compute the perfect reflection direction
        wi = reflect(wo, hit_record.shading_normal);

        // Compute the cosine of the angle between the normal and the incoming direction
        cosine = max(1e-3, dot(hit_record.shading_normal, wi));

        // The probability density function for Specular BRDF is constant 1
        pdf = 1.0;
        
        // BRDF for specular material
        fr = material.base_color;
    }

    return wi;
}

vec3 SampleRay(vec3 origin, vec3 direction) {
    // Russian Roulette probability for path continuation
    float P_RR = 0.9; // Probability for path continuation (can be tuned)
    vec3 accumulated_color = vec3(0.0); // Accumulated color
    vec3 accumulated_coef = vec3(1.0, 1.0, 1.0);
    uint max_depth = scene_settings.num_bounces;
    
    for (int depth = 0; depth < max_depth; ++depth) {
        // Russian Roulette termination condition
        float ksi = RandomFloat();
        if (ksi > P_RR) {
            break;
        }

        // Compute the direct lighting
        vec3 color_direct = vec3(0.0);
        if (scene_settings.enable_direct_lighting && depth != 0){
            // Define metadata
            float entity_last_cdf = 0.0;
            uint sampled_entity_id = -1;
            uint sampled_triangle_id = -1;
            float sampled_probability = 1.0;
            float random_number = 0.0; 

            // According to the cdf, sample an entity
            random_number = RandomFloat();
            for (uint entity_id = 0; entity_id < scene_settings.num_entity; entity_id++){
                // Choose whether to sample this according to CDF
                if (random_number > metadatas[entity_id].emission_cdf){
                    entity_last_cdf = metadatas[entity_id].emission_cdf;
                    continue;
                }

                // Compute the pdf
                float pdf_this = metadatas[entity_id].emission_cdf - entity_last_cdf;
                entity_last_cdf = metadatas[entity_id].emission_cdf;
                if (pdf_this < 1e-6){
			        continue;
		        }
                
                // Store the entity id and the probability
			    sampled_entity_id = entity_id;
                sampled_probability *= pdf_this; // Use in  rendering function
                break;
	        }
        
            // If we have sampled an entity, sample a triangle
            random_number = RandomFloat();
            if (sampled_entity_id != -1){
                // Get metadata
                uint mesh_id = metadatas[sampled_entity_id].mesh_id;
                uint num_triangles = mesh_metadatas[mesh_id].num_index / 3;
                float triangle_last_cdf = 0.0;

                // According to the cdf, sample a triangle
                for (uint primitive_id = 0; primitive_id < num_triangles; primitive_id++){
                    // Choose whether to sample this according to CDF
                    if (random_number > mesh_cdf_buffers[mesh_id].area_cdfs[primitive_id]){
                        entity_last_cdf = mesh_cdf_buffers[mesh_id].area_cdfs[primitive_id];
                        continue;
                    }

                    // Compute the pdf
                    float pdf_this = mesh_cdf_buffers[mesh_id].area_cdfs[primitive_id] - triangle_last_cdf;
                    triangle_last_cdf = mesh_cdf_buffers[mesh_id].area_cdfs[primitive_id];
                    if (pdf_this < 1e-6){
			            continue;
		            }

                    // Store the entity id and the probability
			        sampled_triangle_id = primitive_id;
                    sampled_probability *= pdf_this; // Use in  rendering function
                    break;
		        }
            }

            // If we have sampled a triangle, sample a point, compute the direct lighting
            if (sampled_triangle_id != -1){
                // Get the vertices
                uint mesh_id = metadatas[sampled_entity_id].mesh_id;
                Vertex v0 = GetVertex(mesh_id, index_buffers[mesh_id].indices[sampled_triangle_id * 3 + 0]);
                Vertex v1 = GetVertex(mesh_id, index_buffers[mesh_id].indices[sampled_triangle_id * 3 + 1]);
                Vertex v2 = GetVertex(mesh_id, index_buffers[mesh_id].indices[sampled_triangle_id * 3 + 2]);

                // Uniformly sample points in triangle
                float coef0 = sqrt(RandomFloat());
                float coef1 = RandomFloat() * (1 - coef0);
                float coef2 = 1 - coef0 - coef1;
                vec3 sampled_point = v0.position * coef0 + v1.position * coef1 + v2.position * coef2;

                // Test whether the light is blocked
                vec3 light_direction = origin - sampled_point;
                float light_distance = length(light_direction);
                light_direction = normalize(light_direction);
                TraceRay(sampled_point, light_direction);
            
                if (ray_payload.t > light_distance - 1e-3){
                    // Origin
                    HitRecord hit_record = ComposeHitRecord(ray_payload, origin, direction);
                    Material origin_material = GetMaterial(hit_record);
                    vec3 origin_normal = origin_material.normal;
                    // Light
                    Material light_material = materials[sampled_entity_id];
                    vec3 emission = light_material.emission;
                    float emission_strength = light_material.emission_strength;

			        // Compute the direct lighting and right normals
			        vec3 light_normal = normalize(cross(v1.position - v0.position, v2.position - v0.position));
			        if (dot(light_normal, light_direction) < 0){
				        light_normal = -light_normal;
			        }
                    if (dot(light_normal, light_direction) < 0){
                        origin_normal = -origin_normal;
                    }

                    // Get the direct lighting
			        float light_area = length(cross(v1.position - v0.position, v2.position - v0.position)) / 2.0;
			        float light_pdf = sampled_probability / light_area;
			        float light_cos = max(1e-3, dot(light_normal, light_direction));
                    float origin_cos = max(1e-3, dot(origin_normal, light_direction));
                    vec3 light_intrinsic = emission * emission_strength;
			        float light_attenuation = light_cos * origin_cos / (light_distance * light_distance);
			        color_direct = light_intrinsic * light_attenuation / light_pdf;
		        }
            }
        }

        // Path tracing
        // Trace the ray to find where it hits
        TraceRay(origin, direction);
        // If the ray hits nothing (background), sample from the environment map
        if (ray_payload.t == -1.0) {
            accumulated_color += EnvmapSample(direction) * accumulated_coef;
            break; // End the loop since we've hit the background
        }

        // Get the hit record (intersection details, normal, material, etc.)
        HitRecord hit_record = ComposeHitRecord(ray_payload, origin, direction);
        Material material = GetMaterial(hit_record);

        if (material.emission_strength > 0.0) {
			accumulated_color += material.emission * material.emission_strength * accumulated_coef;
		    break;
		}

        // Sample a new direction wi using the BRDF (Lambertian or any other model)
        vec3 wi; // New ray direction (outgoing)
        float pdf; // Probability density function for the new direction
        float cosine; // Cosine of the angle between the normal and the incoming direction
        vec3 fr; // BRDF coefficient

        // Sample the material's BRDF
        wi = SampleBRDF(hit_record, material, direction, pdf, cosine, fr);
        vec3 this_coef = fr * cosine / pdf / P_RR;

        // Update the ray origin and direction for the next bounce
        origin = hit_record.position;
        direction = wi;

        // Accumulate radiance from the current bounce
        accumulated_color += accumulated_coef * color_direct;
        accumulated_coef *= this_coef;
    }
    
    return accumulated_color;
}

void main() {
  for (uint i = 0; i < scene_settings.num_sample; i++) {
    uint s = scene_settings.accumulated_sample + i;
    InitRandomSeed(gl_LaunchIDEXT.x, gl_LaunchIDEXT.y, s);
    const vec2 pixelCenter =
        vec2(gl_LaunchIDEXT.xy) + vec2(RandomFloat(), RandomFloat());
    const vec2 inUV = pixelCenter / vec2(gl_LaunchSizeEXT.xy);
    vec2 d = inUV * 2.0 - 1.0;
    mat4 proj = scene_settings.projection;
    proj[0][0] = 1.0 / proj[0][0];
    proj[1][1] = 1.0 / proj[1][1];

    vec4 origin = scene_settings.inv_view[3];  // * vec4(0, 0, 0, 1);
    vec4 target = vec4(d.x, -d.y, 0, 1) * proj;
    vec4 direction = scene_settings.inv_view * vec4(normalize(target.xyz), 0);

    float tmin = 0.001;
    float tmax = 10000.0;

    ray_payload.t = -1.0;
    vec3 sampled_result = SampleRay(origin.xyz, direction.xyz);

    sampled_result = clamp(sampled_result, -scene_settings.clamp_value,
                           scene_settings.clamp_value);

    vec4 accumulated_radiance = vec4(0.0);
    float accumulated_weight = 0.0f;
    accumulated_radiance =
        imageLoad(accumulated_radiance_image, ivec2(gl_LaunchIDEXT.xy));
    accumulated_weight =
        imageLoad(accumulated_weight_image, ivec2(gl_LaunchIDEXT.xy)).r;

    accumulated_radiance *= scene_settings.persistence;
    accumulated_weight *= scene_settings.persistence;

    if (isnan(accumulated_weight) || isnan(accumulated_radiance.r) ||
        isnan(accumulated_radiance.g) || isnan(accumulated_radiance.b) ||
        isnan(accumulated_radiance.a)) {
      accumulated_weight = 0.0;
      accumulated_radiance = vec4(0.0);
    }

    accumulated_radiance += vec4(sampled_result, 1.0);
    accumulated_weight += 1.0f;

    vec4 raw_result = accumulated_radiance / accumulated_weight;

    vec4 resolved_result = pow(scene_settings.exposure * raw_result,
                               vec4(1.0 / scene_settings.gamma));

    imageStore(result_image, ivec2(gl_LaunchIDEXT.xy),
               vec4(resolved_result.rgb, 1.0));
    imageStore(accumulated_radiance_image, ivec2(gl_LaunchIDEXT.xy),
               accumulated_radiance);
    imageStore(accumulated_weight_image, ivec2(gl_LaunchIDEXT.xy),
               vec4(accumulated_weight));
    imageStore(raw_result_image, ivec2(gl_LaunchIDEXT.xy), raw_result);
  }
}
