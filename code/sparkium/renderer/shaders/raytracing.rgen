#version 460
#extension GL_EXT_ray_tracing : enable
#extension GL_EXT_nonuniform_qualifier : enable
#extension GL_EXT_ray_query : enable

#include "entity_metadata.glsl"
#include "material.glsl"
#include "mesh_metadata.glsl"
#include "ray_payload.glsl"
#include "scene_settings.glsl"

// Material material;

layout(set = 0, binding = 0, std140) uniform SceneSettingsUniform {
  SceneSettings scene_settings;
};

layout(set = 0, binding = 1, std430) buffer MaterialBuffer {
  Material materials[];
};

layout(set = 0, binding = 2, std430) buffer EntityMetadataBuffer {
  EntityMetadata metadatas[];
};

layout(set = 1, binding = 0) uniform
    accelerationStructureEXT scene;  // Built in attribute, don't need to define

layout(set = 2, binding = 0, std430) buffer VertexBuffers {
  float vertex_data[];
}
vertex_buffers[];

layout(set = 2, binding = 1, std430) buffer IndexBuffers {
  uint indices[];
}
index_buffers[];

layout(set = 2, binding = 2) buffer AreaCDFBuffers {
  float area_cdfs[];
}
mesh_cdf_buffers[];

layout(set = 2, binding = 3, std430) buffer MeshMetadataBuffers {
  MeshMetadata mesh_metadatas[];
};

layout(set = 2, binding = 4) uniform texture2D sampled_textures[];

layout(set = 2, binding = 5) uniform sampler samplers[];

#define ENVMAP_SET 3
#include "envmap.glsl"

layout(set = ENVMAP_SET, binding = 2, std430) buffer EnvmapCdfData {
  float envmap_cdf[];
};

#include "random.glsl"

layout(set = 4, binding = 0, rgba8) uniform image2D result_image;

layout(set = 4,
       binding = 1,
       rgba32f) uniform image2D accumulated_radiance_image;

layout(set = 4, binding = 2, r32f) uniform image2D accumulated_weight_image;

layout(set = 4, binding = 3, rgba32f) uniform image2D raw_result_image;

layout(location = 0) rayPayloadEXT RayPayload ray_payload;

#include "hit_record.glsl"
#include "shadow_ray.glsl"
#include "trace_ray.glsl"

float CosTheta(vec3 w){
    return w.y;
}

vec4 SampleTextureLinear(uint texture_id, vec2 uv) {
  return texture(sampler2D(sampled_textures[texture_id], samplers[0]), uv);
}

vec4 SampleTextureNearest(uint texture_id, vec2 uv) {
  return texture(sampler2D(sampled_textures[texture_id], samplers[1]), uv);
}

vec3 EnvmapSample(vec3 direction) {
  return texture(
             sampler2D(sampled_textures[envmap_data.envmap_id], samplers[0]),
             SampleEnvmapUV(direction))
             .xyz *
         envmap_data.scale;
}

Material GetMaterial(HitRecord hit_record) {
  Material material = materials[hit_record.entity_id];
  material.normal = normalize(mat3(hit_record.tangent, hit_record.bitangent,
                                   hit_record.shading_normal) *
                              ((material.normal - 0.5) * 2.0));
  material.base_color *=
      SampleTextureLinear(hit_record.albedo_texture_id, hit_record.tex_coord)
          .xyz *
      SampleTextureLinear(
          hit_record.albedo_detail_texture_id,
          hit_record.tex_coord * hit_record.detail_scale_offset.xy +
              hit_record.detail_scale_offset.zw)
          .xyz;
  return material;
}

vec3 SampleHemisphere(vec3 normal) {
    // Randomly sample spherical coordinates
    float xi1 = RandomFloat();
    float xi2 = RandomFloat();

    // Convert from spherical to Cartesian coordinates
    // theta is the angle from the normal
    float theta = acos(sqrt(1.0 - xi1));  // theta ¡Ê [0, pi]
    float phi = 2.0 * PI * xi2;            // phi ¡Ê [0, 2*pi]

    // Spherical to Cartesian conversion
    float x = sin(theta) * cos(phi);
    float y = sin(theta) * sin(phi);
    float z = cos(theta);

    // Create the hemisphere direction based on the surface normal
    vec3 sampledDirection = vec3(x, y, z);

    // If the normal vector is pointing downward, reverse the direction
    if (dot(normal, sampledDirection) < 0.0) {
        sampledDirection = -sampledDirection;
    }

    return sampledDirection;
}

float LerpFloat(float a, float b, float alpha){
    return a * (1.0 - alpha) + b * alpha;
}

vec3 LerpVec3(vec3 a, vec3 b, float alpha){
    return a * (1.0 - alpha) + b * alpha;
}

vec3 CalculateTint(vec3 baseColor){
    float luminance  = dot(vec3(0.3, 0.6, 1.0), baseColor);
    return (luminance > 0.0) ? baseColor * (1.0 / luminance) : vec3(1.0);
}

vec3 EvaluateSheen(Material material, vec3 wo, vec3 wm, vec3 wi){
    if (material.sheen <= 0.0){
        return vec3(0.0);
    }
    float dotHL = dot(wm, wi);
    vec3 tint = CalculateTint(material.base_color);
    vec3 lerp = LerpVec3(vec3(1.0), tint, material.sheen_tint);
    return material.sheen * lerp * pow(1.0 - dotHL, 5.0);
}

float GTR1(float absDotHL, float a){
    if(a >= 1) {
        return 1.0 / PI;
    }

    float a2 = a * a;
    return (a2 - 1.0) / (PI * log2(a2) * (1.0 + (a2 - 1.0) * absDotHL * absDotHL));
}

float SeparableSmithGGXG1(vec3 w, float a){
    float a2 = a * a;
    float absDotNV = abs(CosTheta(w));

    return 2.0 / (1.0 + sqrt(a2 + (1.0 - a2) * absDotNV * absDotNV));
}

float FresnelSchlick(float F0, float cosTheta){
	return F0 + (1.0 - F0) * pow(1.0 - cosTheta, 5.0);
}

vec3 FresnelSchlickVec3(vec3 R0, float cosTheta){
	return R0 + (vec3(1.0) - R0) * pow(1.0 - cosTheta, 5.0);
}

float FresnelSchlickWeight(float cosTheta){
	return pow(1.0 - cosTheta, 5.0);
}

float FresnelSchlickR0FromRelativeIOR(float relativeIOR) {
    // Compute (eta - 1) / (eta + 1)
    float etaMinusOne = relativeIOR - 1.0;
    float etaPlusOne = relativeIOR + 1.0;

    // Compute R0
    float r0 = (etaMinusOne / etaPlusOne);
    return r0 * r0;
}

float EvaluateDisneyClearcoat(float clearcoat, float alpha, vec3 wo, vec3 wm, vec3 wi){
    if(clearcoat <= 0.0) {
        return 0.0;
    }

    float absDotNH = abs(CosTheta(wm));
    float absDotNL = abs(CosTheta(wi));
    float absDotNV = abs(CosTheta(wo));
    float dotHL = dot(wm, wi);

    float d = GTR1(absDotNH, LerpFloat(0.1, 0.001, alpha));
    float f = FresnelSchlick(0.04, dotHL);
    float gl = SeparableSmithGGXG1(wi, 0.25);
    float gv = SeparableSmithGGXG1(wo, 0.25);

    return 0.25 * clearcoat * d * f * gl * gv;
}

float GgxAnisotropicD(vec3 wm, float ax, float ay){
    float dotHX2 = wm.x * wm.x;
    float dotHY2 = wm.z * wm.z;
    float cosTheta = CosTheta(wm);
    float cos2Theta = cosTheta * cosTheta;
    float ax2 = ax * ax;
    float ay2 = ay * ay;
    float coef = dotHX2 / ax2 + dotHY2 / ay2 + cos2Theta;

    return 1.0 / (PI * ax * ay * coef * coef);
}

float SeparableSmithGGXG1(vec3 w, vec3 wm, float ax, float ay){
    float dotHW = dot(w, wm);
    if (dotHW <= 0.0) {
        return 0.0;
    }
    float cosTheta = CosTheta(w);
    float absTanTheta = abs(sqrt(1.0 - cosTheta * cosTheta) / cosTheta);
    if(isinf(absTanTheta)) {
        return 0.0;
    }
    float CosPhi = CosTheta(w);
    float SinPhi = sqrt(1.0 - CosPhi * CosPhi);
    float a = sqrt(CosPhi * CosPhi * ax * ax + SinPhi * SinPhi * ay * ay);
    float a2Tan2Theta = a * a * absTanTheta * absTanTheta;

    float lambda = 0.5 * (-1.0 + sqrt(1.0 + a2Tan2Theta));
    return 1.0 / (1.0 + lambda);
}

void GgxVndfAnisotropicPdf(vec3 wi, vec3 wm, vec3 wo, float ax, float ay, out float fPdf){
    // Compute the GGX Anisotropic NDF D(wm)
    float D = GgxAnisotropicD(wm, ax, ay);
    float cosThetaM = abs(CosTheta(wm));

    // Compute the initial PDF value
    float pdf = D * cosThetaM;

    // Assign the same PDF for forward and reverse directions
    fPdf = pdf;
}

float FresnelDielectric(float cosThetaI, float etaI, float etaT) {
    cosThetaI = clamp(cosThetaI, -1.0, 1.0);

    // Check if we are entering or exiting the material
    bool entering = cosThetaI > 0.0;
    float etaIncident = etaI;
    float etaTransmitted = etaT;

    if (!entering) {
        // Swap the indices of refraction
        etaIncident = etaT;
        etaTransmitted = etaI;
        cosThetaI = abs(cosThetaI);
    }

    // Compute sin squared of transmitted angle using Snell's Law
    float sinThetaI = sqrt(max(0.0, 1.0 - cosThetaI * cosThetaI));
    float sinThetaT = etaIncident / etaTransmitted * sinThetaI;

    // Total internal reflection
    if (sinThetaT >= 1.0) {
        return 1.0;
    }

    float cosThetaT = sqrt(max(0.0, 1.0 - sinThetaT * sinThetaT));

    // Compute Fresnel reflectance using the Fresnel equations
    float rParl = ((etaTransmitted * cosThetaI) - (etaIncident * cosThetaT)) /
                  ((etaTransmitted * cosThetaI) + (etaIncident * cosThetaT));
    float rPerp = ((etaIncident * cosThetaI) - (etaTransmitted * cosThetaT)) /
                  ((etaIncident * cosThetaI) + (etaTransmitted * cosThetaT));
    float reflectance = (rParl * rParl + rPerp * rPerp) * 0.5;

    return reflectance;
}

vec3 DisneyFresnel(Material material, vec3 wo, vec3 wm, vec3 wi, float relativeIOR){
    float dotHV = abs(dot(wm, wo));

    vec3 tint = CalculateTint(material.base_color);

    vec3 R0 = FresnelSchlickR0FromRelativeIOR(relativeIOR) * LerpVec3(vec3(1.0), tint, material.specular_tint);
    R0 = LerpVec3(R0, material.base_color, material.metallic);

    float dielectricFresnel = FresnelDielectric(dotHV, 1.0, relativeIOR);
    vec3 metallicFresnel = FresnelSchlickVec3(R0, dot(wi, wm));

    return LerpVec3(vec3(dielectricFresnel), metallicFresnel, material.metallic);
}

vec3 EvaluateDisneyBRDF(Material material, vec3 wo, vec3 wm, vec3 wi, float relativeIOR){

    float dotNL = CosTheta(wi);
    float dotNV = CosTheta(wo);
    if(dotNL <= 0.0 || dotNV <= 0.0) {
        return vec3(0.0);
    }

    float aspect = sqrt(1.0 - material.anisotropic * 0.9);
    float ax = max(0.001, material.roughness * material.roughness / aspect);
    float ay = max(0.001, material.roughness * material.roughness * aspect);

    float d = GgxAnisotropicD(wm, ax, ay);
    float gl = SeparableSmithGGXG1(wi, wm, ax, ay);
    float gv = SeparableSmithGGXG1(wo, wm, ax, ay);

    vec3 f = DisneyFresnel(material, wo, wm, wi, relativeIOR);

    // d * gl * gv * f / (4.0f * dotNL * dotNV);
    return d * gv * gl * f / (4.0 * dotNL * dotNV);
    // return gl * f * abs(CosTheta(wm)) / (4.0 * abs(dot(wo, wm)));
}

vec3 EvaluateDisneySpecTransmission(Material material, vec3 wo, vec3 wm, vec3 wi, float ax, float ay, bool thin, float relativeIOR){
    float n2 = relativeIOR * relativeIOR;
    bool trans=false;
    if (dot(wm, wi) < 0.0){
        trans = true;
        wo = -wo;
        wm = -wm;
    }
    float absDotNL = abs(CosTheta(wi));
    float absDotNV = abs(CosTheta(wo));
    float dotHL = dot(wm, wi);
    float dotHV = dot(wm, wo);
    float absDotHL = abs(dotHL);
    float absDotHV = abs(dotHV);

    float d = GgxAnisotropicD(wm, ax, ay);
    float gl = SeparableSmithGGXG1(wi, wm, ax, ay);
    float gv = SeparableSmithGGXG1(wo, wm, ax, ay);

    float f = FresnelDielectric(dotHV, 1.0, 1.0 / relativeIOR);

    vec3 color;
    if(trans)
        color = sqrt(material.base_color);
    else
        color = material.base_color;
    
    // Note that we are intentionally leaving out the 1/n2 spreading factor since for VCM we will be evaluating
    // particles with this. That means we'll need to model the air-[other medium] transmission if we ever place
    // the camera inside a non-air medium.
    float c = (absDotHL * absDotHV) / (absDotNL * absDotNV);
    float t = n2 / ((dotHL + relativeIOR * dotHV) * (dotHL + relativeIOR * dotHV));
    // return color * material.transmission;
    // if (trans) 
    //    return color * c * t * (1.0 - f) * gl * gv * d * material.transmission;
    // return color * c * t * f * gl * gv * d;
    if (trans)
        return color * c * t * (1.0 - f) * gv * gl * d * material.transmission;
    else
        return color * d * gv * gl * f / (4.0 * absDotNL * absDotNV);
}

float EvaluateDisneyDiffuse(Material material, vec3 wo, vec3 wm, vec3 wi, bool thin){
    float dotNL = abs(CosTheta(wi));
    float dotNV = abs(CosTheta(wo));
    float dotHL = abs(dot(wi, wm));

    float fl = FresnelSchlickWeight(dotNL);
    float fv = FresnelSchlickWeight(dotNV);

    float hanrahanKrueger = 0.0;

    // if (thin ...)
    if(material.subsurface > 0.0) {
        float fss90 = dotHL * dotHL * material.roughness;
        float fss = LerpFloat(1.0, fss90, fl) * LerpFloat(1.0, fss90, fv);

        float ss = 1.25 * (fss * (1.0 / (dotNL + dotNV) - 0.5) + 0.5);
        hanrahanKrueger = ss;
    }

    float lambert = 1.0;
    float rr = 0.5 + 2.0 * material.roughness * dotHL * dotHL;
    float retro = (1.0 + fl * (rr - 1.0)) * (1.0 + fv * (rr - 1.0));
    float subsurfaceApprox = LerpFloat(retro, hanrahanKrueger, material.subsurface);

    return 1.0 / PI * subsurfaceApprox;
    return 1.0 / PI * (retro + subsurfaceApprox * (1.0 - 0.5 * fl) * (1.0 - 0.5 * fv));
}

void CalculateLobePdfs(Material material, out float pMetallic, out float pDiffuse, out float pSpecTrans, out float pClearcoat){
    float metallicBRDF   = material.metallic;
    float specularBSDF   = (1.0 - material.metallic) * material.specular * material.transmission;
    float dielectricBRDF = (1.0 - material.specular * material.transmission) * (1.0 - material.metallic);

    float specularWeight     = metallicBRDF + dielectricBRDF;
    float transmissionWeight = specularBSDF;
    float diffuseWeight      = dielectricBRDF;
    float clearcoatWeight    = 1.0 * min(1.0, max(0.0, material.clearcoat)); 

    float norm = 1.0 / (specularWeight + transmissionWeight + diffuseWeight + clearcoatWeight);

    pMetallic  = specularWeight     * norm;
    pSpecTrans = transmissionWeight * norm;
    pDiffuse   = diffuseWeight      * norm;
    pClearcoat = clearcoatWeight    * norm;
}

vec3 SampleGgxVndfAnisotropic(vec3 wo, float ax, float ay, float u1, float u2){
    // -- Stretch the view vector so we are sampling as though roughness==1
    vec3 v = normalize(vec3(wo.x * ax, wo.y, wo.z * ay));

    // -- Build an orthonormal basis with v, t1, and t2
    vec3 t1 = (abs(v.y) < 0.9999) ? normalize(cross(v, vec3(0.0, 1.0, 0.0))) : vec3(1.0, 0.0, 0.0);
    vec3 t2 = normalize(cross(t1, v));

    // -- Choose a point on a disk with each half of the disk weighted proportionally to its projection onto direction v
    float a = 1.0 / (1.0 + v.y);
    float r = sqrt(u1);
    float phi = (u2 < a) ? (u2 / a) * PI : PI + (u2 - a) / (1.0 - a) * PI;
    float p1 = r * cos(phi);
    float p2 = r * sin(phi) * ((u2 < a) ? 1.0 : v.y);

    // -- Calculate the normal in this stretched tangent space
    vec3 n = p1 * t1 + p2 * t2 + sqrt(max(0.0, 1.0 - p1 * p1 - p2 * p2)) * v;

    // -- unstretch and normalize the normal
    return normalize(vec3(ax * n.x, n.y, ay * n.z));
}

vec3 SampleDisneyBRDF(Material material, vec3 wo, out float forwardPdf){

    // -- Calculate Anisotropic params
    float aspect = sqrt(1.0 - material.anisotropic * 0.9);
    float ax = max(0.001, material.roughness * material.roughness / aspect);
    float ay = max(0.001, material.roughness * material.roughness * aspect);

    // -- Sample visible distribution of normals
    float r0 = RandomFloat();
    float r1 = RandomFloat();
    vec3 wm = SampleGgxVndfAnisotropic(wo, ax, ay, r0, r1);

    // -- Reflect over wm
    vec3 wi = normalize(reflect(-wo, wm));
    if(wi.y <= 0.0) {
        forwardPdf = 0.0;
        return vec3(0.0);
    }
    // -- Since we're sampling the distribution of visible normals the pdf cancels out with a number of other terms.
    // -- We are left with the weight G2(wi, wo, wm) / G1(wi, wm) and since Disney uses a separable masking function
    // -- we get G1(wi, wm) * G1(wo, wm) / G1(wi, wm) = G1(wo, wm) as our weight.
    GgxVndfAnisotropicPdf(wi, wm, wo, ax, ay, forwardPdf);
    float gl = SeparableSmithGGXG1(wi, wm, ax, ay);
    forwardPdf *= (1.0 / (4.0 * abs(dot(wo, wm)))) * gl;

    return wi;
}

bool Transmit(vec3 wm, vec3 wo, float relativeIOR, out vec3 wi) {
    float cosThetaO = dot(wm, wo);
    float sin2ThetaI = (relativeIOR * relativeIOR) * (1.0 - cosThetaO * cosThetaO);

    if (sin2ThetaI > 1.0) {
        return false;
    }

    float cosThetaI = sqrt(1.0 - sin2ThetaI);

    wi = relativeIOR * -wo + (relativeIOR * cosThetaO - cosThetaI) * wm;
    return true;
}

vec3 SampleDisneySpecTransmission(Material material, vec3 wo, bool thin, out float forwardPdf, bool front, out vec3 wm){
    vec3 wi=vec3(0.0);
    if(CosTheta(wo) == 0.0) {
        forwardPdf = 0.0;
        wi = vec3(0.0);
        return wi;
    }
    //wo.y = -wo.y;

    // -- Scale roughness based on IOR
    // float rscaled = thin ? material.transmission_roughness : material.roughness;
    float rscaled = material.transmission_roughness;
    // calculate all of the anisotropic params
    float taspect = sqrt(1.0 - material.anisotropic * 0.9);
    float tax = max(0.001, rscaled / taspect);
    float tay = max(0.001, rscaled * taspect);
    
    // -- Sample visible distribution of normals
    float r0 = RandomFloat();
    float r1 = RandomFloat();
    wm = SampleGgxVndfAnisotropic(wo, tax, tay, r0, r1);

    float dotVH = dot(wo, wm);
    if(wm.y < 0.0) {
        dotVH = -dotVH;
    }

    float ni = front ? 1.0 : material.ior;
    float nt = front ? material.ior : 1.0;
    float relativeIOR = ni / nt;

    // -- Disney uses the full dielectric Fresnel equation for transmission. We also importance sample F
    // -- to switch between refraction and reflection at glancing angles.
    //float F = FresnelDielectric(dotVH, 1.0, material.ior);
    
    // -- Since we're sampling the distribution of visible normals the pdf cancels out with a number of other terms.
    // -- We are left with the weight G2(wi, wo, wm) / G1(wi, wm) and since Disney uses a separable masking function
    // -- we get G1(wi, wm) * G1(wo, wm) / G1(wi, wm) = G1(wo, wm) as our weight.

    float pdf;
    //if(RandomFloat() <= F) {
        //wi = normalize(reflect(-wo, wm));
        //float gl = SeparableSmithGGXG1(wi, wm, tax, tay);
        //float jacobian = (4 * abs(dot(wo, wm)));
        
    //}
    //else {
        //if(thin) {
            // -- When the surface is thin so it refracts into and then out of the surface during this shading event.
            // -- So the ray is just reflected then flipped and we use the sqrt of the surface color.
            //wi = reflect(-wo, wm);
            //wi.y = -wi.y;
            //trans=true;
        //}
        //else {
            //if(Transmit(wm, wo, relativeIOR, wi)) {
                // wi = vec3(0.0);
                // return wi;
            //    wi = reflect(-wo, wm);
            //    wi.y = -wi.y;
            //    trans=true;
            //}
            //else {
            //    wi = reflect(-wo, wm);
            //}
        //}

       // wi = normalize(wi);
        
        //float dotLH = abs(dot(wi, wm));
        // float jacobian = dotLH / ((dotLH + relativeIOR * dotVH) * (dotLH + relativeIOR * dotVH));
        
    //}
    if(Transmit(wm, wo, relativeIOR, wi)) {
        //wi = reflect(-wo, wm);
        // wi.y = -wi.y;
        pdf = SeparableSmithGGXG1(-wi, wm, tax, tay);
    }
    else {
        wi = reflect(-wo, wm);
        pdf = SeparableSmithGGXG1(wi, wm, tax, tay) / 4.0;
    }
    //return wi;
    if(CosTheta(wi) == 0.0) {
        forwardPdf = 0.0;
        wi = vec3(0.0);
        return wi;
    }

    // if(surface.roughness < 0.01) {
    //    // -- This is a hack to allow us to sample the correct IBL texture when a path bounced off a smooth surface.
    //    sample.flags |= SurfaceEventFlags::eDiracEvent;
    //}

    // -- calculate VNDF pdf terms and apply Jacobian and Fresnel sampling adjustments
    GgxVndfAnisotropicPdf(wi, wm, wo, tax, tay, forwardPdf);
    forwardPdf *= pdf / abs(dot(wo, wm));

    return wi;
}

vec3 SampleDisneyDiffuse(Material material, vec3 wo, bool thin, out float forwardPdf){
    float sign_ = sign(CosTheta(wo));

    vec3 wi = sign_ * SampleHemisphere(vec3(0.0,1.0,0.0));
    vec3 wm = normalize(wi + wo);

    float dotNL = CosTheta(wi);
    if(dotNL == 0.0) {
        forwardPdf = 0.0;
        wi = vec3(0.0);
        return wi;
    }

    float dotNV = CosTheta(wo);

    float pdf = 1.0;

    vec3 color = material.base_color;

    float p = RandomFloat();
    if(p > material.alpha) {
        wi = -wi;
        pdf = (1.0 - material.alpha);
    
       if(thin)
          color = sqrt(color);
    }
    else {
        pdf = material.alpha;
    }
    forwardPdf = pdf / PI;
    return wi;
}

vec3 SampleDisneyClearcoat(Material material, vec3 wo, out float forwardPdf){

    float a = 0.25;
    float a2 = a * a;

    float r0 = RandomFloat();
    float r1 = RandomFloat();
    float cosTheta = sqrt(max(0.0, (1.0 - pow(a2, 1.0 - r0)) / (1.0 - a2)));
    float sinTheta = sqrt(max(0.0, 1.0 - cosTheta * cosTheta));
    float phi = 2.0 * PI * r1;

    vec3 wm = vec3(sinTheta * cos(phi), cosTheta, sinTheta * sin(phi));
    if(dot(wm, wo) < 0.0) {
        wm = -wm;
    }

    vec3 wi = reflect(-wo, wm);
    if(dot(wi, wo) < 0.0) {
        wi = vec3(0.0);
        return wi;
    }

    float clearcoatWeight = material.clearcoat;
    float clearcoatGloss = 1.0 - material.clearcoat_roughness;

    float dotNH = CosTheta(wm);
    float dotLH = dot(wm, wi);
    float absDotNL = abs(CosTheta(wi));
    float absDotNV = abs(CosTheta(wo));

    float d = GTR1(abs(dotNH), LerpFloat(0.1, 0.001, clearcoatGloss));

    float fPdf = d / (4.0 * dot(wo, wm));

    forwardPdf = fPdf;

    return wi;
}

uint SampleAll(HitRecord hit_record, Material material, vec3 wo, out vec3 wm, out vec3 wi, out float pdf) {
    uint type=0;
    switch (material.type){
		case MATERIAL_TYPE_LAMBERTIAN:
			wi = SampleHemisphere(hit_record.shading_normal);
            pdf = 1.0 / PI;
			break;
		case MATERIAL_TYPE_SPECULAR:
			wi = reflect(wo, hit_record.shading_normal);
            pdf = 1.0;
			break;
		case MATERIAL_TYPE_PRINCIPLED:
            bool thin = false;
            float forwardPdf=0.0;
            float relativeIOR = material.ior;
            if (hit_record.front_face){
				relativeIOR = 1.0 / relativeIOR;
			}
            
            wo = -wo;
            mat3 TNB = mat3(hit_record.tangent, hit_record.shading_normal, hit_record.bitangent);
            mat3 tTNB = transpose(TNB);
            wo = normalize(tTNB * wo);
            
            float pMetallic, pDiffuse, pSpecTrans, pClearcoat;
            CalculateLobePdfs(material, pMetallic, pDiffuse, pSpecTrans, pClearcoat);
            float scale = 2.0;
            float r = RandomFloat();
            
            if (r <= pMetallic){
                while(length(wi) < 1e-3){
                    wi = SampleDisneyBRDF(material, wo, forwardPdf);
                }
                wm = normalize(wi + wo);
                type=0;
                pdf = forwardPdf * pMetallic / scale;
            }
            else if (r <= pMetallic + pDiffuse){
                while(length(wi) < 1e-3){
                    wi = SampleDisneyDiffuse(material, wo, thin, forwardPdf);
                }
                wm = normalize(wi + wo);
                type=1;
                pdf = forwardPdf * pDiffuse;
            }
            else if (r <= pMetallic + pDiffuse + pSpecTrans){
                while(length(wi) < 1e-3){
				    wi = SampleDisneySpecTransmission(material, wo, thin, forwardPdf, hit_record.front_face, wm);
                }
                type=2;
                pdf = forwardPdf * pSpecTrans / scale;
			}
			else{
                while(length(wi) < 1e-3){
				    wi = SampleDisneyClearcoat(material, wo, forwardPdf);
                }    
                wm = normalize(wi + wo);
                type=3;
                pdf = forwardPdf * pClearcoat / scale;
			}
            wi = normalize(TNB * wi);
            break;
	}

    return type;
}

vec3 EvaluateAll(HitRecord hit_record, Material material, vec3 wo, vec3 wm, vec3 wi, float P_RR, float pdf, uint type) {
    switch (material.type){
		case MATERIAL_TYPE_LAMBERTIAN:
            return material.base_color / PI / P_RR / pdf;
			break;
		case MATERIAL_TYPE_SPECULAR:
			vec3 w_reflect = reflect(wo, hit_record.shading_normal);
            if (dot(w_reflect, wi) > 1.0 - 1e-3){
                return material.base_color / P_RR / pdf;
            }
            else
                return vec3(0.0);
			break;
		case MATERIAL_TYPE_PRINCIPLED:
            bool thin = false;
            float relativeIOR = material.ior;
            if (hit_record.front_face){
				relativeIOR = 1.0 / relativeIOR;
			}
            
            wo = -wo;
            mat3 TNB = mat3(hit_record.tangent, hit_record.shading_normal, hit_record.bitangent);
            mat3 tTNB = transpose(TNB);
            wo = normalize(tTNB * wo);
            wi = normalize(tTNB * wi);

            switch (type){
                case 0:
                    wm = normalize(wi + wo);
                    float specularWeight = material.metallic + (1.0 - material.metallic) * material.specular * material.transmission;
                    vec3 specular = EvaluateDisneyBRDF(material, wo, wm, wi, relativeIOR);
                    return specularWeight * specular / P_RR / pdf;
                    break;
                case 1:
                    wm = normalize(wi + wo);
                    float diffuseWeight = (1.0 - material.metallic) * (1.0 - material.specular * material.transmission);
                    float diffuse = EvaluateDisneyDiffuse(material, wo, wm, wi, thin);
                    vec3 sheen = EvaluateSheen(material, wo, wm, wi);
                    return diffuseWeight * (diffuse * material.base_color + sheen) / P_RR / pdf;
                    break;
                case 2:
                    float rscaled = material.transmission_roughness;
                    // calculate all of the anisotropic params
                    float taspect = sqrt(1.0 - material.anisotropic * 0.9);
                    float tax = max(0.001, rscaled / taspect);
                    float tay = max(0.001, rscaled * taspect);
                    float transWeight = (1.0 - material.metallic) * material.specular * material.transmission;
                    vec3 transmission = EvaluateDisneySpecTransmission(material, wo, wm, wi, tax, tay, thin, relativeIOR);
                    return transWeight * transmission / P_RR / pdf; 
                    break;
                case 3:
                    wm = normalize(wi + wo);
                    float clearcoatWeight = 1.0 * min(1.0, max(0.0, material.clearcoat)); 
                    float clearcoat = EvaluateDisneyClearcoat(material.clearcoat, 1.0 - material.clearcoat_roughness, wo, wm, wi);
                    return clearcoatWeight * vec3(clearcoat) / P_RR / pdf;
                    break;
            }
            break;
	}
    return vec3(0.0);
}

vec3 EvaluateDirectLight(HitRecord hit_record, vec3 origin, Material material, vec3 wo, vec3 wm, float P_RR, uint type, out float pdf){
    // Compute the direct lighting
    // TODO: disable for transmissive
    vec3 color_direct = vec3(0.0);
    vec3 color_direct_direction = vec3(0.0);
    pdf = 0.0;

    // Define metadata
    float entity_last_cdf = 0.0;
    uint sampled_entity_id = -1;
    uint sampled_triangle_id = -1;
    float sampled_probability = 1.0;

    // According to the cdf, sample an entity
    float random_number = RandomFloat();
    for (uint entity_id = 0; entity_id < scene_settings.num_entity; entity_id++){
        // Choose whether to sample this according to CDF
        if (random_number > metadatas[entity_id].emission_cdf){
            entity_last_cdf = metadatas[entity_id].emission_cdf;
            continue;
        }

        // Compute the pdf
        float pdf_this = metadatas[entity_id].emission_cdf - entity_last_cdf;
        entity_last_cdf = metadatas[entity_id].emission_cdf;
        if (pdf_this < 1e-6){
			continue;
		}
                
        // Store the entity id and the probability
		sampled_entity_id = entity_id;
        sampled_probability *= pdf_this; // Use in  rendering function
        break;
	}
        
    // If we have sampled an entity, sample a triangle
    random_number = RandomFloat();
    if (sampled_entity_id != -1){
        // Get metadata
        uint mesh_id = metadatas[sampled_entity_id].mesh_id;
        uint num_triangles = mesh_metadatas[mesh_id].num_index / 3;
        float triangle_last_cdf = 0.0;

        // According to the cdf, sample a triangle
        for (uint primitive_id = 0; primitive_id < num_triangles; primitive_id++){
            // Choose whether to sample this according to CDF
            if (random_number > mesh_cdf_buffers[mesh_id].area_cdfs[primitive_id]){
                entity_last_cdf = mesh_cdf_buffers[mesh_id].area_cdfs[primitive_id];
                continue;
            }

            // Compute the pdf
            float pdf_this = mesh_cdf_buffers[mesh_id].area_cdfs[primitive_id] - triangle_last_cdf;
            triangle_last_cdf = mesh_cdf_buffers[mesh_id].area_cdfs[primitive_id];
            if (pdf_this < 1e-6){
			    continue;
		    }

            // Store the entity id and the probability
			sampled_triangle_id = primitive_id;
            sampled_probability *= pdf_this; // Use in  rendering function
            break;
		}
    }

    // If we have sampled a triangle, sample a point, compute the direct lighting
    if (sampled_triangle_id != -1){
        // Get the vertices
        uint mesh_id = metadatas[sampled_entity_id].mesh_id;
        Vertex v0 = GetVertex(mesh_id, index_buffers[mesh_id].indices[sampled_triangle_id * 3 + 0]);
        Vertex v1 = GetVertex(mesh_id, index_buffers[mesh_id].indices[sampled_triangle_id * 3 + 1]);
        Vertex v2 = GetVertex(mesh_id, index_buffers[mesh_id].indices[sampled_triangle_id * 3 + 2]);

        // Uniformly sample points in triangle
        float coef0 = sqrt(RandomFloat());
        float coef1 = RandomFloat() * (1 - coef0);
        float coef2 = 1 - coef0 - coef1;
        vec3 sampled_point = v0.position * coef0 + v1.position * coef1 + v2.position * coef2;

        // Test whether the light is blocked
        vec3 light_direction = origin - sampled_point;
        float light_distance = length(light_direction);
        light_direction = normalize(light_direction);
        color_direct_direction = normalize(sampled_point - origin);
        TraceRay(sampled_point, light_direction);

        if (ray_payload.t > light_distance - 1e-3){
            // Origin
            Material origin_material = material;
            vec3 origin_normal = origin_material.normal;
            // Light
            Material light_material = materials[sampled_entity_id];
            vec3 emission = light_material.emission;
            float emission_strength = light_material.emission_strength;

			// Compute the direct lighting and right normals
			vec3 light_normal = normalize(cross(v1.position - v0.position, v2.position - v0.position));
			if (dot(light_normal, light_direction) < 0){
				light_normal = -light_normal;
			}
            if (dot(origin_normal, light_direction) < 0){
                origin_normal = -origin_normal;
            }

            // Get the direct lighting
			float light_area = length(cross(v1.position - v0.position, v2.position - v0.position)) / 2.0;
			        
			float light_cos = max(1e-3, dot(light_normal, light_direction));
            float origin_cos = max(1e-3, dot(origin_normal, light_direction));
            vec3 light_intrinsic = emission * emission_strength;
			float light_attenuation = light_cos * origin_cos / (light_distance * light_distance);
            pdf = sampled_probability / light_area;
			color_direct = light_intrinsic * light_attenuation;
		}
    }

    // Return the direct lighting
    if (length(color_direct) > 1e-6)
        return color_direct * EvaluateAll(hit_record, material, wo, wm, color_direct_direction, P_RR, pdf, type);
    return vec3(0.0);

}

vec3 SampleRay(vec3 origin, vec3 direction) {
    // Russian Roulette probability for path continuation
    float P_RR = 0.9; // Probability for path continuation (can be tuned)
    vec3 accumulated_color = vec3(0.0); // Accumulated color
    vec3 accumulated_coef = vec3(1.0);
    uint max_depth = scene_settings.num_bounces;

    vec3 wm=vec3(0.0);

    
    float color_direct_pdf;
    vec3 color_direct;
    float color_indirect_pdf; 
    vec3 color_indirect;

    // Record for variable needed in the next iteration
    HitRecord last_hit_record;
    Material last_material;
    vec3 last_direction;
    uint last_type;
    for (int depth = 0; depth <= max_depth; ++depth) {
        // Accumulate radiance from the current bounce
        
        if (depth!=0 && scene_settings.enable_direct_lighting)
            color_direct = EvaluateDirectLight(last_hit_record, origin, last_material, last_direction, wm, P_RR, last_type, color_direct_pdf);

        // Path tracing
        TraceRay(origin, direction);
        // If the ray hits nothing (background), sample from the environment map
        if (ray_payload.t == -1.0) {
            accumulated_color += EnvmapSample(direction) * accumulated_coef;
            break; // End the loop since we've hit the background
        }

        // Get the hit record (intersection details, normal, material, etc.)
        HitRecord hit_record = ComposeHitRecord(ray_payload, origin, direction);
        Material material = GetMaterial(hit_record);
        
        // Multiple importance sampling on light, compute shading
        if (material.emission_strength > 1e-4){ // When indirect light hit the light source
            if (scene_settings.enable_direct_lighting && color_direct_pdf > 1e-6){ // Multiple importance sampling
			    accumulated_color += accumulated_coef * (color_direct_pdf * color_direct) / (color_direct_pdf + color_indirect_pdf);
                accumulated_color += accumulated_coef * (color_indirect_pdf * material.emission * material.emission_strength) / (color_direct_pdf + color_indirect_pdf);
			}
            else // No direct light case
                accumulated_color += accumulated_coef * material.emission * material.emission_strength;
		}
        else { // Otherwise, only direct light
            accumulated_color += accumulated_coef * color_direct;
        }
        
        // This is the actual ends of the loop
        if (depth == max_depth)
            break;
        
        // Russian Roulette termination condition
        float ksi = RandomFloat();
        if (ksi > P_RR) {
            break;
        }

        // Multiple importance sampling on the material's BRDF
        vec3 wi;
        uint type = SampleAll(hit_record, material, direction, wm, wi, color_indirect_pdf);

        // Compute the color for the next bounce
        vec3 color_indirect = EvaluateAll(hit_record, material, direction, wm, wi, P_RR, color_indirect_pdf, type);
        
        // Update the ray origin and direction for the next bounce'
        last_direction = direction;
        last_material = material;
        last_hit_record = hit_record;
        last_type = type;

        // Next ray
        origin = hit_record.position;
        direction = wi;
        accumulated_coef *= color_indirect;
    }
    
    return accumulated_color;
}

void main() {
  for (uint i = 0; i < scene_settings.num_sample; i++) {
    uint s = scene_settings.accumulated_sample + i;
    InitRandomSeed(gl_LaunchIDEXT.x, gl_LaunchIDEXT.y, s);
    const vec2 pixelCenter =
        vec2(gl_LaunchIDEXT.xy) + vec2(RandomFloat(), RandomFloat());
    const vec2 inUV = pixelCenter / vec2(gl_LaunchSizeEXT.xy);
    vec2 d = inUV * 2.0 - 1.0;
    mat4 proj = scene_settings.projection;
    proj[0][0] = 1.0 / proj[0][0];
    proj[1][1] = 1.0 / proj[1][1];

    vec4 origin = scene_settings.inv_view[3];  // * vec4(0, 0, 0, 1);
    vec4 target = vec4(d.x, -d.y, 0, 1) * proj;
    vec4 direction = scene_settings.inv_view * vec4(normalize(target.xyz), 0);

    float tmin = 0.001;
    float tmax = 10000.0;

    ray_payload.t = -1.0;
    vec3 sampled_result = SampleRay(origin.xyz, direction.xyz);

    sampled_result = clamp(sampled_result, -scene_settings.clamp_value,
                           scene_settings.clamp_value);

    vec4 accumulated_radiance = vec4(0.0);
    float accumulated_weight = 0.0f;
    accumulated_radiance =
        imageLoad(accumulated_radiance_image, ivec2(gl_LaunchIDEXT.xy));
    accumulated_weight =
        imageLoad(accumulated_weight_image, ivec2(gl_LaunchIDEXT.xy)).r;

    accumulated_radiance *= scene_settings.persistence;
    accumulated_weight *= scene_settings.persistence;

    if (isnan(accumulated_weight) || isnan(accumulated_radiance.r) ||
        isnan(accumulated_radiance.g) || isnan(accumulated_radiance.b) ||
        isnan(accumulated_radiance.a)) {
      accumulated_weight = 0.0;
      accumulated_radiance = vec4(0.0);
    }

    accumulated_radiance += vec4(sampled_result, 1.0);
    accumulated_weight += 1.0f;

    vec4 raw_result = accumulated_radiance / accumulated_weight;

    vec4 resolved_result = pow(scene_settings.exposure * raw_result,
                               vec4(1.0 / scene_settings.gamma));

    imageStore(result_image, ivec2(gl_LaunchIDEXT.xy),
               vec4(resolved_result.rgb, 1.0));
    imageStore(accumulated_radiance_image, ivec2(gl_LaunchIDEXT.xy),
               accumulated_radiance);
    imageStore(accumulated_weight_image, ivec2(gl_LaunchIDEXT.xy),
               vec4(accumulated_weight));
    imageStore(raw_result_image, ivec2(gl_LaunchIDEXT.xy), raw_result);
  }
}
